<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RxBox</title>
  <style>
    body { margin: 0; background: #0e0e11; color: #eaeaf0; font-family: system-ui, Arial; }
    #ui { padding: 8px; display: flex; gap: 8px; align-items: center; }
    button { background: #2b2b36; color: #fff; border: none; padding: 6px 10px; cursor: pointer; }
    button.active { background: #4c6fff; }
    canvas { display: block; margin: 0 auto; background: #111; image-rendering: pixelated; }
  </style>
</head>
<body>
  <div id="ui">
    <strong>RxBox</strong>
    <button id="sand" class="active">Sand</button>
    <button id="water">Water</button>
    <button id="wall">Wall</button>
    <span style="opacity:.7">Left click: draw â€¢ Right click: erase</span>
  </div>
  <canvas id="c"></canvas>

  <script>
    // --- Config ---
    const SCALE = 4;          // pixel size
    const W = 200, H = 120;   // grid size

    const canvas = document.getElementById('c');
    canvas.width = W * SCALE;
    canvas.height = H * SCALE;
    const ctx = canvas.getContext('2d');

    // --- Materials ---
    const EMPTY = 0, SAND = 1, WATER = 2, WALL = 3;
    let current = SAND;

    const colors = {
      [EMPTY]: '#111',
      [SAND]: '#d7c07a',
      [WATER]: '#4aa3ff',
      [WALL]: '#777'
    };

    // --- World ---
    const grid = new Uint8Array(W * H);
    const idx = (x, y) => x + y * W;

    // --- Input ---
    let mouseDown = false;
    let erase = false;

    canvas.addEventListener('mousedown', e => {
      mouseDown = true;
      erase = e.button === 2;
      paint(e);
    });
    canvas.addEventListener('mouseup', () => mouseDown = false);
    canvas.addEventListener('mousemove', e => mouseDown && paint(e));
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    function paint(e) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / SCALE);
      const y = Math.floor((e.clientY - rect.top) / SCALE);
      if (x < 0 || y < 0 || x >= W || y >= H) return;
      grid[idx(x, y)] = erase ? EMPTY : current;
    }

    // --- UI ---
    const setActive = (btn) => {
      document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    };
    sand.onclick = () => (current = SAND, setActive(sand));
    water.onclick = () => (current = WATER, setActive(water));
    wall.onclick = () => (current = WALL, setActive(wall));

    // --- Simulation ---
    function update() {
      for (let y = H - 2; y >= 0; y--) {
        for (let x = 0; x < W; x++) {
          const i = idx(x, y);
          const cell = grid[i];

          if (cell === SAND) {
            fall(x, y, SAND);
          } else if (cell === WATER) {
            flow(x, y);
          }
        }
      }
    }

    function fall(x, y, type) {
      const below = idx(x, y + 1);
      if (grid[below] === EMPTY || grid[below] === WATER) {
        grid[below] = type;
        grid[idx(x, y)] = EMPTY;
      } else {
        const dir = Math.random() < 0.5 ? -1 : 1;
        const nx = x + dir;
        if (nx >= 0 && nx < W && grid[idx(nx, y + 1)] === EMPTY) {
          grid[idx(nx, y + 1)] = type;
          grid[idx(x, y)] = EMPTY;
        }
      }
    }

    function flow(x, y) {
      const below = idx(x, y + 1);
      if (grid[below] === EMPTY) {
        grid[below] = WATER;
        grid[idx(x, y)] = EMPTY;
        return;
      }
      const dir = Math.random() < 0.5 ? -1 : 1;
      const nx = x + dir;
      if (nx >= 0 && nx < W && grid[idx(nx, y)] === EMPTY) {
        grid[idx(nx, y)] = WATER;
        grid[idx(x, y)] = EMPTY;
      }
    }

    // --- Render ---
    function draw() {
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          ctx.fillStyle = colors[grid[idx(x, y)]];
          ctx.fillRect(x * SCALE, y * SCALE, SCALE, SCALE);
        }
      }
    }

    // --- Loop ---
    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
